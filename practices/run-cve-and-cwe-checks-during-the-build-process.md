# Run CVE and CWE Checks During the Build Process

Modern software development relies heavily on third-party libraries and frameworks, which accelerates delivery but introduces significant risk if those dependencies contain known vulnerabilities. Integrating checks for Common Vulnerabilities and Exposures (CVE) and Common Weakness Enumeration (CWE) directly into the build process is a critical practice for maintaining a secure software supply chain. By automating these scans, teams can detect known security flaws in their dependencies and identify common coding errors in their own source code before the software is ever deployed.

This practice is a fundamental aspect of "shifting left," moving security assessments earlier in the delivery lifecycle. Instead of waiting for a security audit just before a release—or worse, discovering a breach in production—developers receive immediate feedback on the security posture of their changes. If a scan detects a critical CVE in a library or a dangerous coding pattern (CWE), the build can be configured to fail automatically, acting as a quality gate that prevents insecure code from progressing further down the pipeline.

Implementing these checks within the Continuous Integration (CI) environment fosters a culture where security is everyone's responsibility, not just that of the security team. It ensures that security hygiene is maintained continuously rather than periodically. Over time, this reduces the cost of remediation, as fixing a vulnerability during the coding phase is significantly faster and less expensive than patching a live system.

## Supported Capabilities

### [Continuous Integration](/capabilities/continuous-integration.md)

Continuous Integration relies on automated feedback mechanisms to verify the health of the codebase with every change. Integrating CVE and CWE scanning into the CI server ensures that security verification happens as frequently as unit testing. This allows teams to detect and resolve security issues immediately after code is committed, preventing broken or insecure builds from accumulating.

### [Pervasive Security](/capabilities/pervasive-security.md)

Pervasive security is about integrating security practices into the daily work of development rather than treating it as an external approval phase. By running vulnerability checks during the build, the team ensures that security is built-in rather than bolted-on. This practice empowers developers to own the security of their components and ensures that the software remains deployable at any time without fear of hidden vulnerabilities.

### [Test Automation](/capabilities/test-automation.md)

While test automation typically focuses on functional correctness, it should also encompass non-functional requirements like security. Treating CVE and CWE scans as automated tests allows the team to enforce security standards programmatically and consistently. Just as a build fails when a unit test fails, the build should fail when a high-severity vulnerability is introduced, ensuring a consistent standard of quality.

### [Code Maintainability](/capabilities/code-maintainability.md)

CWE checks analyze source code for architectural flaws and coding patterns known to lead to weaknesses. Addressing these issues as soon as they are identified limits how far risky patterns and dependencies can spread through the codebase. This reduces the likelihood of painful, high-risk upgrade and remediation efforts later, when delayed fixes have compounded into larger, more time-consuming changes.
